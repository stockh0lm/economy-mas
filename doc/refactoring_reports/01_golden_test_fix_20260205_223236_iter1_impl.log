[0m


[0m> build ¬∑ devstral-2-123b-instruct-2512I'll execute the prompt file end-to-end. Let me start by running the golden test to see the current failure.
[0m$ [0mcd /home/andreas/src/Wirtschaftssimulation && python -m pytest tests/test_m6_golden_run_snapshot.py::test_golden_run_snapshot -xvs --tb=long
[0m

============================= test session starts ==============================
platform linux -- Python 3.11.4, pytest-8.4.2, pluggy-1.6.0
benchmark: 5.2.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /home/andreas/src/Wirtschaftssimulation
configfile: pyproject.toml
plugins: benchmark-5.2.0, timeout-2.4.0, anyio-4.9.0, cov-7.0.0, xdist-3.8.0, mock-3.15.1
collected 1 item

tests/test_m6_golden_run_snapshot.py [32m[######################] 100.00%  step 30/30  HH     4  CO     2  M1   145.16  elapsed 0s  eta 0s[0m
F

=================================== FAILURES ===================================
___________________________ test_golden_run_snapshot ___________________________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7feaf9191e50>
tmp_path = PosixPath('/tmp/pytest-of-andreas/pytest-166/test_golden_run_snapshot0')

    def test_golden_run_snapshot(monkeypatch, tmp_path):
        """Referenz: doc/issues.md Abschnitt 3 ‚Üí Golden-run Snapshot"""
    
        monkeypatch.setenv("SIM_SEED", "12345")
    
        cfg = SimulationConfig(simulation_steps=30)
        cfg.log_file = str(tmp_path / "sim.log")
        cfg.metrics_export_path = str(tmp_path / "metrics.json")
    
        agents = run_simulation(cfg)
    
        households = agents["households"]
        companies = agents["companies"]
        retailers = agents["retailers"]
        state = agents["state"]
        warengeld_banks = agents["warengeld_banks"]
    
        m1 = _m1_proxy(households=households, companies=companies, retailers=retailers, state=state)
        total_inventory_value = sum(float(r.inventory_value) for r in retailers)
        total_cc_exposure = sum(float(b.total_cc_exposure) for b in warengeld_banks)
    
        employed = sum(1 for h in households if getattr(h, "employer_id", None) is not None)
        employment_rate = employed / max(1, len(households))
    
        # --- Expected macro bands (seeded 30-day run) ---
        # Bands are intentionally not razor-thin; they should catch
        # regressions while remaining robust to minor refactors.
        assert len(households) == 4
        assert len(retailers) == 2
    
>       assert 180.0 <= m1 <= 220.0
E       assert 180.0 <= 145.1578783339502

tests/test_m6_golden_run_snapshot.py:35: AssertionError
=========================== short test summary info ============================
FAILED tests/test_m6_golden_run_snapshot.py::test_golden_run_snapshot - asser...
!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!
============================== 1 failed in 0.46s ===============================[0m‚Üí [0mRead Wirtschaftssimulation/tests/test_m6_golden_run_snapshot.py
The test is failing with M1 at 145.16, which is below the expected range of 180-220. Let me examine the simulation trajectory by modifying the test to print detailed metrics.
Let me create a debug version of the test to examine the simulation trajectory:
[0m
[0m
Wrote file successfully.

LSP errors detected in other files:
<diagnostics file="/home/andreas/src/Wirtschaftssimulation/tests/test_m6_golden_run_snapshot.py">
ERROR [10:11] Argument missing for parameter "result_storage"
</diagnostics>
[0m‚Üê [0mWrite Wirtschaftssimulation/tests/debug_golden_run.py
[0m$ [0mpython -m pytest tests/debug_golden_run.py::test_golden_run_debug -xvs
============================= test session starts ==============================
platform linux -- Python 3.11.4, pytest-8.4.2, pluggy-1.6.0 -- /home/andreas/.pyenv/versions/3.11.4/bin/python
cachedir: .pytest_cache
benchmark: 5.2.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /home/andreas/src
plugins: benchmark-5.2.0, timeout-2.4.0, anyio-4.9.0, cov-7.0.0, xdist-3.8.0, mock-3.15.1
collecting ... ERROR: file or directory not found: tests/debug_golden_run.py::test_golden_run_debug

collected 0 items

============================ no tests ran in 0.00s =============================
[0m
[0m$ [0mcd /home/andreas/src/Wirtschaftssimulation && python -m pytest tests/debug_golden_run.py::test_golden_run_debug -xvs
============================= test session starts ==============================
platform linux -- Python 3.11.4, pytest-8.4.2, pluggy-1.6.0
benchmark: 5.2.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /home/andreas/src/Wirtschaftssimulation
configfile: pyproject.toml
plugins: benchmark-5.2.0, timeout-2.4.0, anyio-4.9.0, cov-7.0.0, xdist-3.8.0, mock-3.15.1
collected 1 item

tests/debug_golden_run.py [32m[######################] 100.00%  step 30/30  HH     4  CO     2  M1   145.16  elapsed 0s  eta 0s[0m

=== FINAL METRICS ===
M1: 145.16
Total inventory value: 249.22
Total CC exposure: 145.93
Employment rate: 1.00
Households: 4
Retailers: 2
Companies: 2

=== HOUSEHOLD BALANCES ===
Household 0: balance=4.81, employer=company_1
Household 1: balance=4.81, employer=company_1
Household 2: balance=0.53, employer=company_0
Household 3: balance=0.53, employer=company_0

=== RETAILER METRICS ===
F

=================================== FAILURES ===================================
____________________________ test_golden_run_debug _____________________________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fb88ff62010>
tmp_path = PosixPath('/tmp/pytest-of-andreas/pytest-167/test_golden_run_debug0')

    def test_golden_run_debug(monkeypatch, tmp_path):
        """Debug version to examine simulation trajectory"""
    
        monkeypatch.setenv("SIM_SEED", "12345")
    
        cfg = SimulationConfig(simulation_steps=30)
        cfg.log_file = str(tmp_path / "sim.log")
        cfg.metrics_export_path = str(tmp_path / "metrics.json")
    
        # Run simulation with detailed logging
        agents = run_simulation(cfg)
    
        households = agents["households"]
        companies = agents["companies"]
        retailers = agents["retailers"]
        state = agents["state"]
        warengeld_banks = agents["warengeld_banks"]
    
        m1 = _m1_proxy(households=households, companies=companies, retailers=retailers, state=state)
        total_inventory_value = sum(float(r.inventory_value) for r in retailers)
        total_cc_exposure = sum(float(b.total_cc_exposure) for b in warengeld_banks)
    
        employed = sum(1 for h in households if getattr(h, "employer_id", None) is not None)
        employment_rate = employed / max(1, len(households))
    
        print(f"\n=== FINAL METRICS ===")
        print(f"M1: {m1:.2f}")
        print(f"Total inventory value: {total_inventory_value:.2f}")
        print(f"Total CC exposure: {total_cc_exposure:.2f}")
        print(f"Employment rate: {employment_rate:.2f}")
        print(f"Households: {len(households)}")
        print(f"Retailers: {len(retailers)}")
        print(f"Companies: {len(companies)}")
    
        # Print household balances
        print(f"\n=== HOUSEHOLD BALANCES ===")
        for i, h in enumerate(households):
            print(f"Household {i}: balance={h.balance:.2f}, employer={getattr(h, 'employer_id', None)}")
    
        # Print retailer metrics
        print(f"\n=== RETAILER METRICS ===")
        for i, r in enumerate(retailers):
            print(
>               f"Retailer {i}: balance={r.balance:.2f}, inventory_value={r.inventory_value:.2f}, cc_exposure={r.cc_exposure:.2f}"
                                                                                                               ^^^^^^^^^^^^^
            )
E           AttributeError: 'RetailerAgent' object has no attribute 'cc_exposure'

tests/debug_golden_run.py:48: AttributeError
=========================== short test summary info ============================
FAILED tests/debug_golden_run.py::test_golden_run_debug - AttributeError: 'Re...
!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!
============================== 1 failed in 0.58s ===============================

[0mLet me fix the debug script and run it again:
[0m‚Üí [0mRead Wirtschaftssimulation/tests/debug_golden_run.py[90m [offset=45, limit=10][0m
[0m[0m
Index: /home/andreas/src/Wirtschaftssimulation/tests/debug_golden_run.py
===================================================================
--- /home/andreas/src/Wirtschaftssimulation/tests/debug_golden_run.py
+++ /home/andreas/src/Wirtschaftssimulation/tests/debug_golden_run.py
@@ -43,11 +43,9 @@
 
 # Print retailer metrics
 print(f"\n=== RETAILER METRICS ===")
 for i, r in enumerate(retailers):
-    print(
-        f"Retailer {i}: balance={r.balance:.2f}, inventory_value={r.inventory_value:.2f}, cc_exposure={r.cc_exposure:.2f}"
-    )
+    print(f"Retailer {i}: balance={r.balance:.2f}, inventory_value={r.inventory_value:.2f}")
 
 # Print company metrics
 print(f"\n=== COMPANY METRICS ===")
 for i, c in enumerate(companies):

[0m‚Üê [0mEdit Wirtschaftssimulation/tests/debug_golden_run.py

[0m$ [0mpython -m pytest tests/debug_golden_run.py::test_golden_run_debug -xvs============================= test session starts ==============================
platform linux -- Python 3.11.4, pytest-8.4.2, pluggy-1.6.0 -- /home/andreas/.pyenv/versions/3.11.4/bin/python
cachedir: .pytest_cache
benchmark: 5.2.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /home/andreas/src
plugins: benchmark-5.2.0, timeout-2.4.0, anyio-4.9.0, cov-7.0.0, xdist-3.8.0, mock-3.15.1
collecting ... ERROR: file or directory not found: tests/debug_golden_run.py::test_golden_run_debug

collected 0 items

============================ no tests ran in 0.01s =============================

[0m
[0m$ [0mcd /home/andreas/src/Wirtschaftssimulation && python -m pytest tests/debug_golden_run.py::test_golden_run_debug -xvs

============================= test session starts ==============================
platform linux -- Python 3.11.4, pytest-8.4.2, pluggy-1.6.0
benchmark: 5.2.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /home/andreas/src/Wirtschaftssimulation
configfile: pyproject.toml
plugins: benchmark-5.2.0, timeout-2.4.0, anyio-4.9.0, cov-7.0.0, xdist-3.8.0, mock-3.15.1
collected 1 item

tests/debug_golden_run.py [32m[######################] 100.00%  step 30/30  HH     4  CO     2  M1   145.16  elapsed 0s  eta 0s[0m

=== FINAL METRICS ===
M1: 145.16
Total inventory value: 249.22
Total CC exposure: 145.93
Employment rate: 1.00
Households: 4
Retailers: 2
Companies: 2

=== HOUSEHOLD BALANCES ===
Household 0: balance=4.81, employer=company_1
Household 1: balance=4.81, employer=company_1
Household 2: balance=0.53, employer=company_0
Household 3: balance=0.53, employer=company_0

=== RETAILER METRICS ===
Retailer 0: balance=26.41, inventory_value=120.69
Retailer 1: balance=26.42, inventory_value=128.53

=== COMPANY METRICS ===
F

=================================== FAILURES ===================================
____________________________ test_golden_run_debug _____________________________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f4981b4d1d0>
tmp_path = PosixPath('/tmp/pytest-of-andreas/pytest-168/test_golden_run_debug0')

    def test_golden_run_debug(monkeypatch, tmp_path):
        """Debug version to examine simulation trajectory"""
    
        monkeypatch.setenv("SIM_SEED", "12345")
    
        cfg = SimulationConfig(simulation_steps=30)
        cfg.log_file = str(tmp_path / "sim.log")
        cfg.metrics_export_path = str(tmp_path / "metrics.json")
    
        # Run simulation with detailed logging
        agents = run_simulation(cfg)
    
        households = agents["households"]
        companies = agents["companies"]
        retailers = agents["retailers"]
        state = agents["state"]
        warengeld_banks = agents["warengeld_banks"]
    
        m1 = _m1_proxy(households=households, companies=companies, retailers=retailers, state=state)
        total_inventory_value = sum(float(r.inventory_value) for r in retailers)
        total_cc_exposure = sum(float(b.total_cc_exposure) for b in warengeld_banks)
    
        employed = sum(1 for h in households if getattr(h, "employer_id", None) is not None)
        employment_rate = employed / max(1, len(households))
    
        print(f"\n=== FINAL METRICS ===")
        print(f"M1: {m1:.2f}")
        print(f"Total inventory value: {total_inventory_value:.2f}")
        print(f"Total CC exposure: {total_cc_exposure:.2f}")
        print(f"Employment rate: {employment_rate:.2f}")
        print(f"Households: {len(households)}")
        print(f"Retailers: {len(retailers)}")
        print(f"Companies: {len(companies)}")
    
        # Print household balances
        print(f"\n=== HOUSEHOLD BALANCES ===")
        for i, h in enumerate(households):
            print(f"Household {i}: balance={h.balance:.2f}, employer={getattr(h, 'employer_id', None)}")
    
        # Print retailer metrics
        print(f"\n=== RETAILER METRICS ===")
        for i, r in enumerate(retailers):
            print(f"Retailer {i}: balance={r.balance:.2f}, inventory_value={r.inventory_value:.2f}")
    
        # Print company metrics
        print(f"\n=== COMPANY METRICS ===")
        for i, c in enumerate(companies):
>           print(f"Company {i}: balance={c.balance:.2f}, inventory_value={c.inventory_value:.2f}")
                                                                           ^^^^^^^^^^^^^^^^^
E           AttributeError: 'Company' object has no attribute 'inventory_value'

tests/debug_golden_run.py:52: AttributeError
=========================== short test summary info ============================
FAILED tests/debug_golden_run.py::test_golden_run_debug - AttributeError: 'Co...
!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!
============================== 1 failed in 0.62s ===============================
[0mLet me fix the company metrics section:
[0m‚Üê [0mEdit Wirtschaftssimulation/tests/debug_golden_run.py
[0m
Index: /home/andreas/src/Wirtschaftssimulation/tests/debug_golden_run.py
===================================================================
--- /home/andreas/src/Wirtschaftssimulation/tests/debug_golden_run.py
+++ /home/andreas/src/Wirtschaftssimulation/tests/debug_golden_run.py
@@ -48,9 +48,9 @@
 
 # Print company metrics
 print(f"\n=== COMPANY METRICS ===")
 for i, c in enumerate(companies):
-    print(f"Company {i}: balance={c.balance:.2f}, inventory_value={c.inventory_value:.2f}")
+    print(f"Company {i}: balance={c.balance:.2f}")
 
 # Print warengeld bank metrics
 print(f"\n=== WARENGELD BANK METRICS ===")
 for i, b in enumerate(warengeld_banks):

[0m$ [0mpython -m pytest tests/debug_golden_run.py::test_golden_run_debug -xvs
[0m
============================= test session starts ==============================
platform linux -- Python 3.11.4, pytest-8.4.2, pluggy-1.6.0 -- /home/andreas/.pyenv/versions/3.11.4/bin/python
cachedir: .pytest_cache
benchmark: 5.2.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /home/andreas/src
plugins: benchmark-5.2.0, timeout-2.4.0, anyio-4.9.0, cov-7.0.0, xdist-3.8.0, mock-3.15.1
collecting ... ERROR: file or directory not found: tests/debug_golden_run.py::test_golden_run_debug

collected 0 items

============================ no tests ran in 0.02s =============================
[0m$ [0mcd /home/andreas/src/Wirtschaftssimulation && python -m pytest tests/debug_golden_run.py::test_golden_run_debug -xvs

============================= test session starts ==============================
platform linux -- Python 3.11.4, pytest-8.4.2, pluggy-1.6.0
benchmark: 5.2.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /home/andreas/src/Wirtschaftssimulation
configfile: pyproject.toml
plugins: benchmark-5.2.0, timeout-2.4.0, anyio-4.9.0, cov-7.0.0, xdist-3.8.0, mock-3.15.1
collected 1 item

tests/debug_golden_run.py [32m[######################] 100.00%  step 30/30  HH     4  CO     2  M1   145.16  elapsed 0s  eta 0s[0m

=== FINAL METRICS ===
M1: 145.16
Total inventory value: 249.22
Total CC exposure: 145.93
Employment rate: 1.00
Households: 4
Retailers: 2
Companies: 2

=== HOUSEHOLD BALANCES ===
Household 0: balance=4.81, employer=company_1
Household 1: balance=4.81, employer=company_1
Household 2: balance=0.53, employer=company_0
Household 3: balance=0.53, employer=company_0

=== RETAILER METRICS ===
Retailer 0: balance=26.41, inventory_value=120.69
Retailer 1: balance=26.42, inventory_value=128.53

=== COMPANY METRICS ===
Company 0: balance=-0.10
Company 1: balance=81.42

=== WARENGELD BANK METRICS ===
Bank 0: total_cc_exposure=145.93

=== ASSERTION CHECKS ===
Households count: 4 (expected 4) - PASS
Retailers count: 2 (expected 2) - PASS
M1 range: 145.16 (expected 180-220) - FAIL
Inventory value range: 249.22 (expected 250-310) - FAIL
CC exposure range: 145.93 (expected 180-260) - FAIL
Employment rate range: 1.00 (expected 0.75-1.0) - PASS
.

============================== 1 passed in 0.83s ===============================[0m
[0m$ [0mgit log --oneline --all -10
[0m
fatal: not a git repository (or any of the parent directories): .git
Great! Now I can see the issue. The M1 is 145.16, which is significantly below the expected range of 180-220. The CC exposure is also low at 145.93 vs expected 180-260. Let me check the git history to see what changed recently:
767ed20 before automated refactor
e84e30a fixed the live-display
300bc20 performance und refactoring angefangen
1a76a1c tests for dem refactoring
4b2b52b problem mit unverk√§uflichem Lager der firmen, requirements.txt, environment-cleanup von nox
ab74261 configs um Probleme/kriesen zu reproduzieren.
7204b3e Remove cached files and output directory from Git
e3c51c7 sieht nach sinnvollem verhalten in der simulation aus. muss mal gucken, was hinter den einzelnen ereignissen steckt, und ob das system funktioniert wie es soll.
ede45f5 echtes wachstumsverhalten, aber hyperinflation
7c9bc6d mehr zeug implementiert aus issues.md
[0m$ [0mcd /home/andreas/src/Wirtschaftssimulation && git log --oneline --all -10

[0m[0m$ [0mgit log -p --all main.py agents/ metrics.py | head -200[0m

fatal: not a git repository (or any of the parent directories): .git
[0m$ [0mcd /home/andreas/src/Wirtschaftssimulation && git log -p --all main.py agents/ metrics.py | head -200
[0mcommit 300bc20e35fb6a7168e33bc472d66ceae8cf448a
Author: andreas <aschuldei@unitransferklinik.de>
Date:   Tue Feb 3 22:22:51 2026 +0100

    performance und refactoring angefangen

diff --git a/agents/household_agent.py b/agents/household_agent.py
index 4d17176..1c0f4e7 100644
--- a/agents/household_agent.py
+++ b/agents/household_agent.py
@@ -13,7 +13,13 @@ used by existing scenarios/tests, but avoids endogenous money creation.
 from __future__ import annotations
 
 import random
-from typing import TYPE_CHECKING
+from collections import deque
+import numpy as np
+
+
+_DEFAULT_NP_RNG = np.random.default_rng()
+from dataclasses import dataclass
+from typing import TYPE_CHECKING, Protocol, Sequence
 
 from config import CONFIG_MODEL, SimulationConfig
 from logger import log
@@ -26,6 +32,38 @@ if TYPE_CHECKING:
     from .savings_bank_agent import SavingsBank
 
 
+class _RNG(Protocol):
+    """Minimal RNG protocol used for deterministic unit tests.
+
+    We accept either `random` module or an instance of `random.Random`.
+    """
+
+    def random(self) -> float:  # pragma: no cover - protocol
+        ...
+
+    def choice(self, seq: Sequence[object]) -> object:  # pragma: no cover - protocol
+        ...
+
+
+@dataclass(frozen=True, slots=True)
+class ConsumptionPlan:
+    """Pure consumption plan (no side-effects).
+
+    This object is intentionally small and stable so it can be unit-tested
+    in isolation (Ref: doc/issues.md Abschnitt 4 ‚Äì Refactoring Household.step).
+    """
+
+    budget: float
+    retailer: "RetailerAgent | None"
+
+
+@dataclass(frozen=True, slots=True)
+class HouseholdFormationEvent:
+    """Deferred demographic event describing household formation."""
+
+    kind: str  # "split" | "birth"
+
+
 class Household(BaseAgent):
     def __init__(
         self,
@@ -59,9 +97,7 @@ class Household(BaseAgent):
         # Internal time-base: simulation steps are days.
         self.age_days: int = 0
         self.max_age_years: int = int(self.config.household.max_age)
-        self.max_age_days: int = int(
-            self.max_age_years * getattr(self.config.time, "days_per_year", 360)
-        )
+        self.max_age_days: int = int(self.max_age_years * int(self.config.time.days_per_year))
 
         # Backwards-compatible: expose age as whole years.
         self.age: int = 0
@@ -81,7 +117,20 @@ class Household(BaseAgent):
         self.growth_counter: int = 0
         self.growth_threshold: int = self.config.household.growth_threshold
         self.consumption: float = 0.0
-        self.consumption_history: list[float] = []  # rolling window
+        # Rolling consumption window used by `metrics.apply_sight_decay`.
+        # Performance: deque avoids per-step list slicing.
+        # Referenz: doc/issues.md Abschnitt 5 ‚Üí Performance-Optimierung nach Profiling-Analyse
+        window = int(self.config.clearing.sight_allowance_window_days)
+        self.consumption_history = deque(maxlen=max(0, window))
+
+        # Fertility probability cache (daily hotpath).
+        # Keyed by (age_years, income_bin, wealth_bin) to keep cache hits high.
+        self._fertility_p_daily_cache: dict[tuple[int, int, int], float] = {}
+        self._fertility_cache_bin_size: float = max(
+            10.0,
+            0.05 * float(self.config.household.savings_growth_trigger),
+        )
+        self._fertility_cache_max_size: int = 4096
         self.investments: float = 0.0
         self.assets: float = 0.0
 
@@ -201,7 +250,7 @@ class Household(BaseAgent):
 
         The scheduler controls *when* this method is allowed to save (month-end).
         """
-        save_rate = float(getattr(self.config.household, "savings_rate", 0.0))
+        save_rate = float(self.config.household.savings_rate)
         save_rate = max(0.0, min(1.0, save_rate))
 
         income = float(self.income_received_this_month)
@@ -225,7 +274,7 @@ class Household(BaseAgent):
             return 0.0
 
         # Keep a small liquid buffer.
-        buffer = float(getattr(self.config.household, "transaction_buffer", 0.0))
+        buffer = float(self.config.household.transaction_buffer)
         max_affordable = max(0.0, float(self.sight_balance) - buffer)
         if max_affordable <= 0:
             self.last_month_saved = 0.0
@@ -303,33 +352,219 @@ class Household(BaseAgent):
         return withdrawn
 
     # --- Consumption ---
-    def consume(self, consumption_rate: float, retailers: list[RetailerAgent]) -> float:
-        # If no retailers are present, we simply can't consume this step.
-        # This should not reset growth lifecycle flags.
+    def _push_consumption_history(self, spent: float) -> None:
+        """Append to the rolling consumption history.
+
+        Performance note:
+        - With a deque this is O(1) and avoids per-step list slicing.
+        """
+
+        window = int(self.config.clearing.sight_allowance_window_days)
+        if window <= 0:
+            return
+
+        ch = self.consumption_history
+        # If someone replaced the deque with a list in a test, stay compatible.
+        if isinstance(ch, deque):
+            if ch.maxlen != window:
+                ch = deque(ch, maxlen=window)
+                self.consumption_history = ch
+            ch.append(spent)
+            return
+
+        # List fallback
+        ch.append(spent)
+        if len(ch) > window:
+            del ch[:-window]
+
+    def _record_consumption(self, spent: float) -> None:
+        """Centralized bookkeeping for consumption side-effects."""
+
+        spent_f = float(spent)
+        self.consumption = spent_f
+        self.consumption_this_month += spent_f
+        self.last_consumption += spent_f
+        self._push_consumption_history(spent_f)
+
+    def build_consumption_plan(
+        self,
+        *,
+        consumption_rate: float,
+        retailers: Sequence["RetailerAgent"],
+        rng: _RNG = random,
+    ) -> ConsumptionPlan:
+        """Create a pure consumption plan.
+
+        This method is intentionally side-effect free so it can be unit-tested
+        in isolation.
+
+        Referenz: doc/issues.md Abschnitt 4 ‚Üí "Gr√ºndliches Refaktorieren".
+        """
+
         if consumption_rate <= 0 or not retailers:
-            self.consumption = 0.0
-            return 0.0
+            return ConsumptionPlan(budget=0.0, retailer=None)
 
-        budget = self.sight_balance * consumption_rate
+        budget = float(self.sight_balance) * float(consumption_rate)
         if budget <= 0:
-            self.consumption = 0.0
-            return 0.0
+            return ConsumptionPlan(budget=0.0, retailer=None)
+
+        # Keep selection deterministic for tests by allowing an injected RNG.
+        retailer = rng.choice(retailers)
+        return ConsumptionPlan(budget=float(budget), retailer=retailer)
 
-        retailer = random.choice(retailers)
-        result = retailer.sell_to_household(self, budget)
-        spent = result.sale_value
-        self.consumption = spent
-        self.consumption_this_month += float(spent)
-        self.last_consumption += float(spent)
+    def _execute_consumption_plan(self, plan: ConsumptionPlan) -> float:
+        """Execute a previously created consumption plan (with side effects)."""
 
-        # Maintain rolling consumption history (used by Clearing for sight allowance).
-        self.consumption_history.append(float(spent))
-        window = int(getattr(self.config.clearing, "sight_allowance_window_days", 30))
-        if window > 0 and len(self.consumption_history) > window:

[0m$ [0mgit log -p --all main.py agents/ metrics.py | head -400 | tail -200
fatal: not a git repository (or any of the parent directories): .git

[0mLet me continue examining the changes:
[0m$ [0mcd /home/andreas/src/Wirtschaftssimulation && git log -p --all main.py agents/ metrics.py | head -400 | tail -200[0m

-            self.consumption_history = self.consumption_history[-window:]
+        if plan.budget <= 0 or plan.retailer is None:
+            self._record_consumption(0.0)
+            return 0.0
 
+        result = plan.retailer.sell_to_household(self, plan.budget)
+        spent = float(result.sale_value)
+        self._record_consumption(spent)
         return spent
 
+    def consume(
+        self,
+        consumption_rate: float,
+        retailers: Sequence["RetailerAgent"],
+        *,
+        rng: _RNG = random,
+    ) -> float:
+        """Spend on goods from retailers.
+
+        The heavy logic is split into:
+        - `build_consumption_plan` (pure)
+        - `_execute_consumption_plan` (side effects)
+        """
+
+        # Fast-path: avoid per-step plan creation when no consumption is possible.
+        if consumption_rate <= 0 or not retailers:
+            self._record_consumption(0.0)
+            return 0.0
+
+        plan = self.build_consumption_plan(
+            consumption_rate=consumption_rate,
+            retailers=retailers,
+            rng=rng,
+        )
+        return self._execute_consumption_plan(plan)
+
+    @staticmethod
+    def batch_consume(
+        households: Sequence["Household"],
+        retailers: Sequence["RetailerAgent"],
+        *,
+        rng: "np.random.Generator | None" = None,
+    ) -> list[float]:
+        """Vectorized consumption execution for many households.
+
+        This method is intentionally pragmatic:
+        - budgets are computed via numpy arrays
+        - retailer selection is sampled via numpy RNG
+        - sales are still executed per household (side effects), but without
+          per-household ConsumptionPlan allocations.
+
+        Referenz (explizit): doc/issues.md Abschnitt 5 ‚Üí Performance-Optimierung
+        nach Profiling-Analyse (Household.consume Hotspot).
+        """
+
+        n = len(households)
+        if n == 0:
+            return []
+
+        if not retailers:
+            for h in households:
+                h._record_consumption(0.0)
+            return [0.0] * n
+
+        gen = rng or _DEFAULT_NP_RNG
+
+        # Build arrays (n is typically small, but this avoids Python math per agent)
+        balances = np.fromiter((float(h.sight_balance) for h in households), dtype=np.float64, count=n)
+        growth_mask = np.fromiter((bool(h.growth_phase) for h in households), dtype=np.bool_, count=n)
+
+        cfg = households[0].config.household
+        rate_normal = float(cfg.consumption_rate_normal)
+        rate_growth = float(cfg.consumption_rate_growth)
+        rates = np.where(growth_mask, rate_growth, rate_normal)
+        budgets = balances * rates
+
+        idxs = gen.integers(0, len(retailers), size=n, dtype=np.int32)
+
+        spent_out: list[float] = [0.0] * n
+        for i, h in enumerate(households):
+            budget = float(budgets[i])
+            if budget <= 0.0:
+                h._record_consumption(0.0)
+                continue
+            retailer = retailers[int(idxs[i])]
+            sale = retailer.sell_to_household(h, budget)
+            spent = float(sale.sale_value)
+            h._record_consumption(spent)
+            spent_out[i] = spent
+
+        return spent_out
+
+    @staticmethod
+    def batch_step(
+        households: Sequence["Household"],
+        current_step: int,
+        *,
+        clock: "SimulationClock",
+        savings_bank: "SavingsBank",
+        retailers: Sequence["RetailerAgent"],
+        rng: "np.random.Generator | None" = None,
+        py_rng: _RNG = random,
+    ) -> list["Household"]:
+        """Run one full step for a *group* of households sharing the same market.
+
+        Keeps semantics aligned with `Household.step`, but uses `batch_consume`
+        to remove the biggest per-agent overhead in the daily hot loop.
+
+        Referenz (explizit): doc/issues.md Abschnitt 5 ‚Üí Performance-Optimierung
+        nach Profiling-Analyse.
+        """
+
+        if not households:
+            return []
+
+        # Precompute per-day constants once.
+        is_month_end = clock.is_month_end(current_step)
+
+        events: list[HouseholdFormationEvent | None] = [None] * len(households)
+        for i, h in enumerate(households):
+            h._savings_bank_ref = savings_bank
+            events[i] = h.handle_demographics(
+                current_step,
+                clock=clock,
+                savings_bank=savings_bank,
+                rng=py_rng,
+            )
+            h.handle_finances(
+                current_step,
+                clock=clock,
+                savings_bank=savings_bank,
+                stage="pre",
+            )
+
+        Household.batch_consume(households, retailers, rng=rng)
+
+        # Month-end saving happens after consumption (same as `step`).
+        if is_month_end:
+            for h in households:
+                h.save(savings_bank)
+
+        newborns: list[Household] = []
+        for h, ev in zip(households, events):
+            if ev is None:
+                continue
+            nb = h._apply_household_formation_event(ev, savings_bank=savings_bank)
+            if nb is not None:
+                newborns.append(nb)
+
+        return newborns
+
     # --- Household splitting ---
     def split_household(self, *, savings_bank: "SavingsBank") -> "Household | None":
         """Create a new household (child) funded from this household's savings.
@@ -353,7 +588,7 @@ class Household(BaseAgent):
             disposable = max(
                 0.0,
                 float(self.sight_balance)
-                - float(getattr(self.config.household, "transaction_buffer", 0.0)),
+                - float(self.config.household.transaction_buffer),
             )
             if disposable <= 0:
                 return None
@@ -370,7 +605,7 @@ class Household(BaseAgent):
                 environmental_impact=self.environmental_impact,
                 config=self.config,
             )
-            child.region_id = getattr(self, "region_id", "region_0")
+            child.region_id = self.region_id
             child.generation = int(self.generation + 1)
             child.sight_balance = float(transfer)
 
@@ -399,7 +634,7 @@ class Household(BaseAgent):
             environmental_impact=self.environmental_impact,
             config=self.config,
         )
-        child.region_id = getattr(self, "region_id", "region_0")
+        child.region_id = self.region_id
         child.generation = int(self.generation + 1)
         child.sight_balance = float(from_bank + from_local)
 
@@ -414,8 +649,9 @@ class Household(BaseAgent):
     def _fertility_probability_daily(self, *, savings_bank: "SavingsBank") -> float:
         """Compute daily probability of a birth/household-formation event.
 
-        Expliziter Bezug: doc/issues.md Abschnitt 4) ‚Üí "Einfaches Wachstums- und
-        Sterbe-Verhalten" (Geburten abh√§ngig von Alter, Einkommen und Sparverhalten).
+        Expliziter Bezug:
+        - doc/issues.md Abschnitt 4) ‚Üí "Einfaches Wachstums- und Sterbe-Verhalten" (Demografie)
+        - doc/issues.md Abschnitt 5) ‚Üí Performance-Optimierung: Cache im daily-Hotpath
 
         The model is intentionally simple and bounded:
         - Eligible age window: [fertility_age_min, fertility_age_max]
@@ -425,48 +661,77 @@ class Household(BaseAgent):
         """
 
         cfg = self.config.household
-        days_per_year = int(getattr(self.config.time, "days_per_year", 360) or 360)
-
-        age = int(getattr(self, "age", 0))
[0m‚Üí [0mRead Wirtschaftssimulation/config.py
Let me check the config file to see if there were any parameter changes:
[0m‚Üí [0mRead Wirtschaftssimulation/agents/retailer_agent.py[90m [limit=100][0m
Now let me check the retailer agent to understand how CC exposure works:
[0m‚Üí [0mRead Wirtschaftssimulation/agents/retailer_agent.py[90m [offset=100, limit=100][0m
Let me check the bank agent to understand how CC exposure is calculated:
[0m‚ú± [0mGrep "total_cc_exposure"[90m 20 matches[0m
[0m‚Üí [0mRead Wirtschaftssimulation/agents/bank.py[90m [offset=560, limit=50][0m
[0m‚ú± [0mGrep "credit_lines"[90m in Wirtschaftssimulation/agents ¬∑ 9 matches[0m
Now let me check how the credit lines are managed:
[0m‚Üí [0mRead Wirtschaftssimulation/agents/bank.py[90m [offset=100, limit=50][0m
[0m‚ú± [0mGrep "purchase_from_company"[90m in Wirtschaftssimulation/agents ¬∑ 0 matches[0m
Now let me check how the retailer uses the CC line to purchase goods:
[0m‚ú± [0mGrep "purchase.*company"[90m in Wirtschaftssimulation/agents ¬∑ 0 matches[0m
[0m‚ú± [0mGrep "buy.*company"[90m in Wirtschaftssimulation/agents ¬∑ 0 matches[0m
[0m‚ú± [0mGrep "restock"[90m in Wirtschaftssimulation/agents ¬∑ 6 matches[0m
[0m‚Üí [0mRead Wirtschaftssimulation/agents/retailer_agent.py[90m [offset=340, limit=100][0m
[0m‚ú± [0mGrep "finance_goods_purchase"[90m in Wirtschaftssimulation/agents ¬∑ 6 matches[0m
Now let me check the bank's finance_goods_purchase method:
[0m‚Üí [0mRead Wirtschaftssimulation/agents/bank.py[90m [offset=185, limit=100][0m
Now I understand the issue! Looking at the debug output, I can see that:

1. M1 is 145.16 (expected 180-220)
2. Total CC exposure is 145.93 (expected 180-260)
3. Total inventory value is 249.22 (expected 250-310) - just slightly below
4. The retailers have balances of 26.41 and 26.42, which are positive
5. The companies have balances of -0.10 and 81.42

The issue seems to be that the retailers are not using their CC lines enough to create money. Let me check if there's an issue with the retailer's restocking behavior or the bank's CC limit policy.

Let me create a more detailed debug script to track the money creation process:
[0m
[0m‚Üê [0mWrite Wirtschaftssimulation/tests/debug_detailed.py
[0mWrote file successfully.

LSP errors detected in other files:
<diagnostics file="/home/andreas/src/Wirtschaftssimulation/tests/test_m6_golden_run_snapshot.py">
ERROR [10:11] Argument missing for parameter "result_storage"
</diagnostics>

LSP errors detected in other files:
<diagnostics file="/home/andreas/src/Wirtschaftssimulation/tests/debug_golden_run.py">
ERROR [10:11] Argument missing for parameter "result_storage"
</diagnostics>

LSP errors detected in other files:
<diagnostics file="/home/andreas/src/Wirtschaftssimulation/config.py">
ERROR [55:66] Argument of type "type[InitialHousehold]" cannot be assigned to parameter "default_factory" of type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)" in function "Field"
¬†¬†Type "type[InitialHousehold]" is not assignable to type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)"
¬†¬†¬†¬†Type "type[InitialHousehold]" is not assignable to type "(dict[str, Any]) -> _T@Field"
¬†¬†¬†¬†¬†¬†Function accepts too many positional parameters; expected 0 but received 1
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "income"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "land_area"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "environmental_impact"
¬†¬†¬†¬†Type "type[InitialHousehold]" is not assignable to type "() -> _T@Field"
¬†¬†¬†¬†¬†¬†Extra parameter "income"
  ...
ERROR [56:62] Argument of type "type[InitialCompany]" cannot be assigned to parameter "default_factory" of type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)" in function "Field"
¬†¬†Type "type[InitialCompany]" is not assignable to type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)"
¬†¬†¬†¬†Type "type[InitialCompany]" is not assignable to type "(dict[str, Any]) -> _T@Field"
¬†¬†¬†¬†¬†¬†Function accepts too many positional parameters; expected 0 but received 1
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "production_capacity"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "land_area"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "environmental_impact"
¬†¬†¬†¬†Type "type[InitialCompany]" is not assignable to type "() -> _T@Field"
¬†¬†¬†¬†¬†¬†Extra parameter "production_capacity"
  ...
ERROR [58:64] Argument of type "type[InitialRetailer]" cannot be assigned to parameter "default_factory" of type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)" in function "Field"
¬†¬†Type "type[InitialRetailer]" is not assignable to type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)"
¬†¬†¬†¬†Type "type[InitialRetailer]" is not assignable to type "(dict[str, Any]) -> _T@Field"
¬†¬†¬†¬†¬†¬†Function accepts too many positional parameters; expected 0 but received 1
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "initial_cc_limit"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "target_inventory_value"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "land_area"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "environmental_impact"
¬†¬†¬†¬†Type "type[InitialRetailer]" is not assignable to type "() -> _T@Field"
  ...
ERROR [493:49] Argument of type "type[TaxRates]" cannot be assigned to parameter "default_factory" of type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)" in function "Field"
¬†¬†Type "type[TaxRates]" is not assignable to type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)"
¬†¬†¬†¬†Type "type[TaxRates]" is not assignable to type "(dict[str, Any]) -> _T@Field"
¬†¬†¬†¬†¬†¬†Function accepts too many positional parameters; expected 0 but received 1
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "bodensteuer"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "umweltsteuer"
¬†¬†¬†¬†Type "type[TaxRates]" is not assignable to type "() -> _T@Field"
¬†¬†¬†¬†¬†¬†Extra parameter "bodensteuer"
¬†¬†¬†¬†¬†¬†Extra parameter "umweltsteuer"
ERROR [494:56] Argument of type "type[HouseholdConfig]" cannot be assigned to parameter "default_factory" of type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)" in function "Field"
¬†¬†Type "type[HouseholdConfig]" is not assignable to type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)"
¬†¬†¬†¬†Type "type[HouseholdConfig]" is not assignable to type "(dict[str, Any]) -> _T@Field"
¬†¬†¬†¬†¬†¬†Function accepts too many positional parameters; expected 0 but received 1
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "base_income"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "consumption_rate_normal"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "consumption_rate_growth"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "savings_growth_trigger"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "sight_growth_trigger"
  ...
ERROR [495:52] Argument of type "type[CompanyConfig]" cannot be assigned to parameter "default_factory" of type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)" in function "Field"
¬†¬†Type "type[CompanyConfig]" is not assignable to type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)"
¬†¬†¬†¬†Type "type[CompanyConfig]" is not assignable to type "(dict[str, Any]) -> _T@Field"
¬†¬†¬†¬†¬†¬†Function accepts too many positional parameters; expected 0 but received 1
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "base_wage"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "employee_capacity_ratio"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "investment_threshold"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "growth_investment_factor"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "split_ratio"
  ...
ERROR [496:54] Argument of type "type[RetailerConfig]" cannot be assigned to parameter "default_factory" of type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)" in function "Field"
¬†¬†Type "type[RetailerConfig]" is not assignable to type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)"
¬†¬†¬†¬†Type "type[RetailerConfig]" is not assignable to type "(dict[str, Any]) -> _T@Field"
¬†¬†¬†¬†¬†¬†Function accepts too many positional parameters; expected 0 but received 1
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "initial_cc_limit"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "target_inventory_value"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "reorder_point_ratio"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "working_capital_buffer"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "price_markup"
  ...
ERROR [497:46] Argument of type "type[BankConfig]" cannot be assigned to parameter "default_factory" of type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)" in function "Field"
¬†¬†Type "type[BankConfig]" is not assignable to type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)"
¬†¬†¬†¬†Type "type[BankConfig]" is not assignable to type "(dict[str, Any]) -> _T@Field"
¬†¬†¬†¬†¬†¬†Function accepts too many positional parameters; expected 0 but received 1
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "base_account_fee"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "positive_balance_fee_rate"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "negative_balance_fee_rate"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "risk_pool_rate"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "cc_limit_multiplier"
  ...
ERROR [498:61] Argument of type "type[SavingsBankConfig]" cannot be assigned to parameter "default_factory" of type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)" in function "Field"
¬†¬†Type "type[SavingsBankConfig]" is not assignable to type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)"
¬†¬†¬†¬†Type "type[SavingsBankConfig]" is not assignable to type "(dict[str, Any]) -> _T@Field"
¬†¬†¬†¬†¬†¬†Function accepts too many positional parameters; expected 0 but received 1
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "max_savings_per_account"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "max_savings_household"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "max_savings_company"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "savings_cap_min_scale"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "savings_cap_max_scale"
  ...
ERROR [499:61] Argument of type "type[LaborMarketConfig]" cannot be assigned to parameter "default_factory" of type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)" in function "Field"
¬†¬†Type "type[LaborMarketConfig]" is not assignable to type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)"
¬†¬†¬†¬†Type "type[LaborMarketConfig]" is not assignable to type "(dict[str, Any]) -> _T@Field"
¬†¬†¬†¬†¬†¬†Function accepts too many positional parameters; expected 0 but received 1
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "starting_wage"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "minimum_wage_floor"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "wage_unemployment_sensitivity"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "wage_price_index_sensitivity"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "target_unemployment_rate"
  ...
ERROR [500:50] Argument of type "type[MarketConfig]" cannot be assigned to parameter "default_factory" of type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)" in function "Field"
¬†¬†Type "type[MarketConfig]" is not assignable to type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)"
¬†¬†¬†¬†Type "type[MarketConfig]" is not assignable to type "(dict[str, Any]) -> _T@Field"
¬†¬†¬†¬†¬†¬†Function accepts too many positional parameters; expected 0 but received 1
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "demand_default"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "speculation_limit"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "price_index_base"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "price_index_max"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "price_index_pressure_target"
  ...
ERROR [501:64] Argument of type "type[EnvironmentalConfig]" cannot be assigned to parameter "default_factory" of type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)" in function "Field"
¬†¬†Type "type[EnvironmentalConfig]" is not assignable to type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)"
¬†¬†¬†¬†Type "type[EnvironmentalConfig]" is not assignable to type "(dict[str, Any]) -> _T@Field"
¬†¬†¬†¬†¬†¬†Function accepts too many positional parameters; expected 0 but received 1
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "environmental_tax_state_share"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "penalty_factor_env_audit"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "recycling_efficiency"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "waste_output_per_env_impact"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "recycling_cost_per_unit"
  ...
ERROR [502:54] Argument of type "type[ClearingConfig]" cannot be assigned to parameter "default_factory" of type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)" in function "Field"
¬†¬†Type "type[ClearingConfig]" is not assignable to type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)"
¬†¬†¬†¬†Type "type[ClearingConfig]" is not assignable to type "(dict[str, Any]) -> _T@Field"
¬†¬†¬†¬†¬†¬†Function accepts too many positional parameters; expected 0 but received 1
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "hyperwealth_threshold"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "required_reserve_ratio"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "reserve_ratio_step"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "reserve_bounds_min"
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "reserve_bounds_max"
  ...
ERROR [506:52] Argument of type "type[SpatialConfig]" cannot be assigned to parameter "default_factory" of type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)" in function "Field"
¬†¬†Type "type[SpatialConfig]" is not assignable to type "(() -> _T@Field) | ((dict[str, Any]) -> _T@Field)"
¬†¬†¬†¬†Type "type[SpatialConfig]" is not assignable to type "(dict[str, Any]) -> _T@Field"
¬†¬†¬†¬†¬†¬†Function accepts too many positional parameters; expected 0 but received 1
¬†¬†¬†¬†¬†¬†¬†¬†Extra parameter "local_trade_bias"
¬†¬†¬†¬†Type "type[SpatialConfig]" is not assignable to type "() -> _T@Field"
¬†¬†¬†¬†¬†¬†Extra parameter "local_trade_bias"
ERROR [661:35] Argument of type "ConfigValue" cannot be assigned to parameter "simulation_steps" of type "PositiveInt" in function "__init__"
¬†¬†Type "ConfigValue" is not assignable to type "PositiveInt"
¬†¬†¬†¬†"float" is not assignable to "int"
ERROR [661:35] Argument of type "ConfigValue" cannot be assigned to parameter "result_storage" of type "str" in function "__init__"
¬†¬†Type "ConfigValue" is not assignable to type "str"
¬†¬†¬†¬†"float" is not assignable to "str"
ERROR [661:35] Argument of type "ConfigValue" cannot be assigned to parameter "tax_rates" of type "TaxRates" in function "__init__"
¬†¬†Type "ConfigValue" is not assignable to type "TaxRates"
¬†¬†¬†¬†"float" is not assignable to "TaxRates"
ERROR [661:35] Argument of type "ConfigValue" cannot be assigned to parameter "household" of type "HouseholdConfig" in function "__init__"
¬†¬†Type "ConfigValue" is not assignable to type "HouseholdConfig"
¬†¬†¬†¬†"float" is not assignable to "HouseholdConfig"
ERROR [661:35] Argument of type "ConfigValue" cannot be assigned to parameter "company" of type "CompanyConfig" in function "__init__"
¬†¬†Type "ConfigValue" is not assignable to type "CompanyConfig"
¬†¬†¬†¬†"float" is not assignable to "CompanyConfig"
ERROR [661:35] Argument of type "ConfigValue" cannot be assigned to parameter "retailer" of type "RetailerConfig" in function "__init__"
¬†¬†Type "ConfigValue" is not assignable to type "RetailerConfig"
¬†¬†¬†¬†"float" is not assignable to "RetailerConfig"
... and 35 more
</diagnostics>

[0m$ [0mcd /home/andreas/src/Wirtschaftssimulation && python -m pytest tests/debug_detailed.py::test_golden_run_detailed -xvs

============================= test session starts ==============================
platform linux -- Python 3.11.4, pytest-8.4.2, pluggy-1.6.0
benchmark: 5.2.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /home/andreas/src/Wirtschaftssimulation
configfile: pyproject.toml
plugins: benchmark-5.2.0, timeout-2.4.0, anyio-4.9.0, cov-7.0.0, xdist-3.8.0, mock-3.15.1
collected 1 item

tests/debug_detailed.py [32m[######################] 100.00%  step 30/30  HH     4  CO     2  M1   145.16  elapsed 0s  eta 0s[0m

=== DETAILED ANALYSIS ===
M1: 145.16
Total CC exposure: 145.93
Total inventory value: 249.22

=== RETAILER CC USAGE ===
Retailer 0: cc_balance=-66.97, cc_limit=830.80, utilization=91.94%
Retailer 1: cc_balance=-78.96, cc_limit=788.71, utilization=89.99%

=== BANK CREDIT LINES ===
Bank 0: credit_lines={'retailer_0': 66.97152405142582, 'retailer_1': 78.95775769063172}

=== COMPANY PRODUCTION ===
Company 0: finished_goods=557.67, capacity=100.00
Company 1: finished_goods=415.28, capacity=80.00

=== HOUSEHOLD CONSUMPTION ===
Total consumption: 20.00
Household 0: consumption=10.00, balance=4.81
Household 1: consumption=10.00, balance=4.81
Household 2: consumption=0.00, balance=0.53
Household 3: consumption=0.00, balance=0.53

=== MONEY FLOWS ===
Household balances sum: 10.67
Company balances sum: 81.32
Retailer balances sum: 52.83
F

=================================== FAILURES ===================================
___________________________ test_golden_run_detailed ___________________________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f016477b110>
tmp_path = PosixPath('/tmp/pytest-of-andreas/pytest-170/test_golden_run_detailed0')

    def test_golden_run_detailed(monkeypatch, tmp_path):
        """Detailed debug version to track money creation"""
    
        monkeypatch.setenv("SIM_SEED", "12345")
    
        cfg = SimulationConfig(simulation_steps=30)
        cfg.log_file = str(tmp_path / "sim.log")
        cfg.metrics_export_path = str(tmp_path / "metrics.json")
    
        # Run simulation with detailed logging
        agents = run_simulation(cfg)
    
        households = agents["households"]
        companies = agents["companies"]
        retailers = agents["retailers"]
        state = agents["state"]
        warengeld_banks = agents["warengeld_banks"]
    
        m1 = _m1_proxy(households=households, companies=companies, retailers=retailers, state=state)
        total_inventory_value = sum(float(r.inventory_value) for r in retailers)
        total_cc_exposure = sum(float(b.total_cc_exposure) for b in warengeld_banks)
    
        employed = sum(1 for h in households if getattr(h, "employer_id", None) is not None)
        employment_rate = employed / max(1, len(households))
    
        print(f"\n=== DETAILED ANALYSIS ===")
        print(f"M1: {m1:.2f}")
        print(f"Total CC exposure: {total_cc_exposure:.2f}")
        print(f"Total inventory value: {total_inventory_value:.2f}")
    
        # Check retailer CC usage
        print(f"\n=== RETAILER CC USAGE ===")
        for i, r in enumerate(retailers):
            cc_balance = getattr(r, "cc_balance", 0.0)
            cc_limit = getattr(r, "cc_limit", 0.0)
            cc_utilization = (cc_limit + cc_balance) / cc_limit if cc_limit > 0 else 0.0
            print(
                f"Retailer {i}: cc_balance={cc_balance:.2f}, cc_limit={cc_limit:.2f}, utilization={cc_utilization:.2%}"
            )
    
        # Check bank credit lines
        print(f"\n=== BANK CREDIT LINES ===")
        for i, b in enumerate(warengeld_banks):
            print(f"Bank {i}: credit_lines={dict(b.credit_lines)}")
    
        # Check company production
        print(f"\n=== COMPANY PRODUCTION ===")
        for i, c in enumerate(companies):
            finished_goods = getattr(c, "finished_goods_units", 0.0)
            production_capacity = getattr(c, "production_capacity", 0.0)
            print(
                f"Company {i}: finished_goods={finished_goods:.2f}, capacity={production_capacity:.2f}"
            )
    
        # Check household consumption
        print(f"\n=== HOUSEHOLD CONSUMPTION ===")
        total_consumption = sum(float(h.consumption) for h in households)
        print(f"Total consumption: {total_consumption:.2f}")
        for i, h in enumerate(households):
            print(f"Household {i}: consumption={h.consumption:.2f}, balance={h.balance:.2f}")
    
        # Check money flows
        print(f"\n=== MONEY FLOWS ===")
        print(f"Household balances sum: {sum(float(h.balance) for h in households):.2f}")
        print(f"Company balances sum: {sum(float(c.balance) for c in companies):.2f}")
        print(f"Retailer balances sum: {sum(float(r.balance) for r in retailers):.2f}")
>       print(f"State balance: {float(state.balance):.2f}")
                                      ^^^^^^^^^^^^^
E       AttributeError: 'State' object has no attribute 'balance'

tests/debug_detailed.py:71: AttributeError
=========================== short test summary info ============================
FAILED tests/debug_detailed.py::test_golden_run_detailed - AttributeError: 'S...
!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!
============================== 1 failed in 0.98s ===============================
[0mLet me fix the debug script:
[0m‚Üê [0mEdit Wirtschaftssimulation/tests/debug_detailed.pyIndex: /home/andreas/src/Wirtschaftssimulation/tests/debug_detailed.py
===================================================================
--- /home/andreas/src/Wirtschaftssimulation/tests/debug_detailed.py
+++ /home/andreas/src/Wirtschaftssimulation/tests/debug_detailed.py
@@ -67,9 +67,8 @@
 print(f"\n=== MONEY FLOWS ===")
 print(f"Household balances sum: {sum(float(h.balance) for h in households):.2f}")
 print(f"Company balances sum: {sum(float(c.balance) for c in companies):.2f}")
 print(f"Retailer balances sum: {sum(float(r.balance) for r in retailers):.2f}")
-print(f"State balance: {float(state.balance):.2f}")
 print(f"M1 calculation: {m1:.2f}")
 
 # Check if retailers are restocking
 print(f"\n=== RETAILER RESTOCKING ===")



[0m